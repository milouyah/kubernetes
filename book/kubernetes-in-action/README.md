# Kubernetes in Action
* http://github.com/luksa/kubernetes-in-action
* 


# 1부. 쿠버네티스 개요

## [1장. 쿠버네티스 소개](Chapter01/README.md)
## [2장. 도커와 쿠버네티스 첫걸음](Chapter02/README.md)


# 2부. 쿠버네티스 핵심 개념

## [3장. 파드: 쿠버네티스에서 컨테이너 실행](Chapter03/README.md)
## [4장. 레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포](Chapter04/README.md)
## [5장. 서비스: 클라이언트가 파드를 검색하고 통신을 가능하게 함](Chapter05/README.md)
## [6장. 볼륨: 컨테이너에 디스크 스토리지 연결](Chpater06/../README.md)



7장. 컨피그맵과 시크릿: 애플리케이션 설정

7.1 컨테이너화된 애플리케이션 설정
7.2 컨테이너에 명령줄 인자 전달
7.2.1 도커에서 명령어와 인자 정의
7.2.2 쿠버네티스에서 명령과 인자 재정의
7.3 컨테이너의 환경변수 설정
7.3.1 컨테이너 정의에 환경변수 지정
7.3.2 변숫값에서 다른 환경변수 참조
7.3.3 하드코딩된 환경변수의 단점
7.4 컨피그맵으로 설정 분리
7.4.1 컨피그맵 소개
7.4.2 컨피그맵 생성
7.4.3 컨피그맵 항목을 환경변수로 컨테이너에 전달
7.4.4 컨피그맵의 모든 항목을 한 번에 환경변수로 전달
7.4.5 컨피그맵 항목을 명령줄 인자로 전달
7.4.6 컨피그맵 볼륨을 사용해 컨피그맵 항목을 파일로 노출
7.4.7 애플리케이션을 재시작하지 않고 애플리케이션 설정 업데이트
7.5 시크릿으로 민감한 데이터를 컨테이너에 전달
7.5.1 시크릿 소개
7.5.2 기본 토큰 시크릿 소개
7.5.3 시크릿 생성
7.5.4 컨피그맵과 시크릿 비교
7.5.5 파드에서 시크릿 사용
7.5.6 이미지를 가져올 때 사용하는 시크릿 이해
7.6 요약


8장. 애플리케이션에서 파드 메타데이터와 그 외의 리소스에 액세스하기

8.1 Downward API로 메타데이터 전달
8.1.1 사용 가능한 메타데이터 이해
8.1.2 환경변수로 메타데이터 노출하기
8.1.3 downwardAPI 볼륨에 파일로 메타데이터 전달
8.2 쿠버네티스 API 서버와 통신하기
8.2.1 쿠버네티스 REST API 살펴보기
8.2.2 파드 내에서 API 서버와 통신
8.2.3 앰배서더 컨테이너를 이용한 API 서버 통신 간소화
8.2.4 클라이언트 라이브러리를 사용해 API 서버와 통신
8.3 요약


9장. 디플로이먼트: 선언적 애플리케이션 업데이트

9.1 파드에서 실행 중인 애플리케이션 업데이트
9.1.1 오래된 파드를 삭제하고 새 파드로 교체
9.1.2 새 파드 기동과 이전 파드 삭제
9.2 레플리케이션컨트롤러로 자동 롤링 업데이트 수행
9.2.1 애플리케이션의 초기 버전 실행
9.2.2 kubectl을 이용한 롤링 업데이트
9.2.3 kubectl rolling-update를 더 이상 사용하지 않는 이유
9.3 애플리케이션을 선언적으로 업데이트하기 위한 디플로이먼트 사용하기
9.3.1 디플로이먼트 생성
9.3.2 디플로이먼트 업데이트
9.3.3 디플로이먼트 롤백
9.3.4 롤아웃 속도 제어
9.3.5 롤아웃 프로세스 일시 중지
9.3.6 잘못된 버전의 롤아웃 방지
9.4 요약


10장. 스테이트풀셋: 복제된 스테이트풀 애플리케이션 배포하기

10.1 스테이트풀 파드 복제하기
10.1.1 개별 스토리지를 갖는 레플리카 여러 개 실행하기
10.1.2 각 파드에 안정적인 아이덴티티 제공하기
10.2 스테이트풀셋 이해하기
10.2.1 스테이트풀셋과 레플리카셋 비교하기
10.2.2 안정적인 네트워크 아이덴티티 제공하기
10.2.3 각 스테이트풀 인스턴스에 안정적인 전용 스토리지 제공하기
10.2.4 스테이트풀셋 보장 이해하기
10.3 스테이트풀셋 사용하기
10.3.1 애플리케이션과 컨테이너 이미지 생성하기
10.3.2 스테이트풀셋을 통한 애플리케이션 배포하기
10.3.3 파드 가지고 놀기
10.4 스테이트풀셋의 피어 디스커버리
10.4.1 DNS를 통한 피어 디스커버리
10.4.2 스테이트풀셋 업데이트
10.4.3 클러스터된 데이터 저장소 사용하기
10.5 스테이트풀셋이 노드 실패를 처리하는 과정 이해하기
10.5.1 노드의 네트워크 연결 해제 시뮬레이션
10.5.2 수동으로 파드 삭제하기
10.6 요약


3부. 쿠버네티스 심화

11장. 쿠버네티스 내부 이해

11.1 아키텍처 이해
11.1.1 쿠버네티스 구성 요소의 분산 특성
11.1.2 쿠버네티스가 etcd를 사용하는 방법
11.1.3 API 서버의 기능
11.1.4 API 서버가 리소스 변경을 클라이언트에 통보하는 방법 이해
11.1.5 스케줄러 이해
11.1.6 컨트롤러 매니저에서 실행되는 컨트롤러 소개
11.1.7 Kubelet이 하는 일
11.1.8 쿠버네티스 서비스 프록시의 역할
11.1.9 쿠버네티스 애드온 소개
11.1.10 모든 것을 함께 가져오기
11.2 컨트롤러가 협업하는 방법
11.2.1 관련된 구성 요소 이해
11.2.2 이벤트 체인
11.2.3 클러스터 이벤트 관찰
11.3 실행 중인 파드에 관한 이해
11.4 파드 간 네트워킹
11.4.1 네트워크는 어떤 모습이어야 하는가
11.4.2 네트워킹 동작 방식 자세히 알아보기
11.4.3 컨테이너 네트워크 인터페이스 소개
11.5 서비스 구현 방식
11.5.1 kube-proxy 소개
11.5.2 kube-proxy가 iptables를 사용하는 방법
11.6 고가용성 클러스터 실행
11.6.1 애플리케이션 가용성 높이기
11.6.2 쿠버네티스 컨트롤 플레인 구성 요소의 가용성 향상
11.7 요약


12장. 쿠버네티스 API 서버 보안

12.1 인증 이해
12.1.1 사용자와 그룹
12.1.2 서비스어카운트 소개
12.1.3 서비스어카운트 생성
12.1.4 파드에 서비스어카운트 할당
12.2 역할 기반 액세스 제어로 클러스터 보안
12.2.1 RBAC 인가 플러그인 소개
12.2.2 RBAC 리소스 소개
12.2.3 롤과 롤바인딩 사용
12.2.4 클러스터롤과 클러스터롤바인딩 사용하기
12.2.5 디폴트 클러스터롤과 클러스터롤바인딩의 이해
12.2.6 인가 권한을 현명하게 부여하기
12.3 요약


13장. 클러스터 노드와 네트워크 보안

13.1 파드에서 호스트 노드의 네임스페이스 사용
13.1.1 파드에서 노드의 네트워크 네임스페이스 사용
13.1.2 호스트 네트워크 네임스페이스를 사용하지 않고 호스트 포트에 바인딩
13.1.3 노드의 PID와 IPC 네임스페이스 사용
13.2 컨테이너의 보안 컨텍스트 구성
13.2.1 컨테이너를 특정 사용자로 실행
13.2.2 컨테이너가 루트로 실행되는 것 방지
13.2.3 특권 모드에서 파드 실행
13.2.4 컨테이너에 개별 커널 기능 추가
13.2.5 컨테이너에서 기능 제거
13.2.6 프로세스가 컨테이너의 파일시스템에 쓰는 것 방지
13.2.7 컨테이너가 다른 사용자로 실행될 때 볼륨 공유
13.3 파드의 보안 관련 기능 사용 제한
13.3.1 PodSecurityPolicy 리소스 소개
13.3.2 runAsUser, fsGroup, supplementalGroups 정책
13.3.3 allowed, default, disallowed 기능 구성
13.3.4 파드가 사용할 수 있는 볼륨 유형 제한
13.3.5 각각의 사용자와 그룹에 다른 PodSecurityPolicies 할당
13.4 파드 네트워크 격리
13.4.1 네임스페이스에서 네트워크 격리 사용
13.4.2 네임스페이스의 일부 클라이언트 파드만 서버 파드에 연결하도록 허용
13.4.3 쿠버네티스 네임스페이스 간 네트워크 격리
13.4.4 CIDR 표기법으로 격리
13.4.5 파드의 아웃바운드 트래픽 제한
13.5 요약


14장. 파드의 컴퓨팅 리소스 관리

14.1 파드 컨테이너의 리소스 요청
14.1.1 리소스 요청을 갖는 파드 생성하기
14.1.2 리소스 요청이 스케줄링에 미치는 영향
14.1.3 CPU 요청이 CPU 시간 공유에 미치는 영향
14.1.4 사용자 정의 리소스의 정의와 요청
14.2 컨테이너에 사용 가능한 리소스 제한
14.2.1 컨테이너가 사용 가능한 리소스 양을 엄격한 제한으로 설정
14.2.2 리소스 제한 초과
14.2.3 컨테이너의 애플리케이션이 제한을 바라보는 방법
14.3 파드 QoS 클래스 이해
14.3.1 파드의 QoS 클래스 정의
14.3.2 메모리가 부족할 때 어떤 프로세스가 종료되는지 이해
14.4 네임스페이스별 파드에 대한 기본 요청과 제한 설정
14.4.1 LimitRange 리소스 소개
14.4.2 LimitRange 오브젝트 생성하기
14.4.3 강제 리소스 제한
14.4.4 기본 리소스 요청과 제한 적용
14.5 네임스페이스의 사용 가능한 총 리소스 제한하기
14.5.1 리소스쿼터 오브젝트 소개
14.5.2 퍼시스턴트 스토리지에 관한 쿼터 지정하기
14.5.3 생성 가능한 오브젝트 수 제한
14.5.4 특정 파드 상태나 QoS 클래스에 대한 쿼터 지정
14.6 파드 리소스 사용량 모니터링
14.6.1 실제 리소스 사용량 수집과 검색
14.6.2 기간별 리소스 사용량 통계 저장 및 분석
14.7 요약


15장. 파드와 클러스터 노드의 오토스케일링

15.1 수평적 파드 오토스케일링
15.1.1 오토스케일링 프로세스 이해
15.1.2 CPU 사용률 기반 스케일링
15.1.3 메모리 소비량에 기반을 둔 스케일링
15.1.4 기타 및 사용자 정의 메트릭 기반 스케일링
15.1.5 오토스케일링에 적합한 메트릭 결정
15.1.6 레플리카를 0으로 감소
15.2 수직적 파드 오토스케일링
15.2.1 리소스 요청 자동 설정
15.2.2 파드가 실행되는 동안 리소스 요청 수정
15.3 수평적 클러스터 노드 확장
15.3.1 클러스터 오토스케일러 소개
15.3.2 클러스터 오토스케일러 활성화
15.3.3 클러스터 스케일 다운 동안에 서비스 중단 제한
15.4 요약


16장. 고급 스케줄링

16.1 테인트와 톨러레이션을 사용해 특정 노드에서 파드 실행 제한
16.1.1 테인트와 톨러레이션 소개
16.1.2 노드에 사용자 정의 테인트 추가하기
16.1.3 파드에 톨러레이션 추가
16.1.4 테이트와 톨러레이션의 활용 방안 이해
16.2 노드 어피니티를 사용해 파드를 특정 노드로 유인하기
16.2.1 하드 노드 어피니티 규칙 지정
16.2.2 파드의 스케줄링 시점에 노드 우선순위 지정
16.3 파드 어피니티와 안티-어피니티를 이용해 파드 함께 배치하기
16.3.1 파드 간 어피니티를 사용해 같은 노드에 파드 배포하기
16.3.2 동일한 랙, 가용 영역 또는 리전에 파드 배포
16.3.3 필수 요구 사항 대신 파드 어피니티 선호도 표현하기
16.3.4 파드 안티-어피니티를 사용해 파드들이 서로 떨어지게 스케줄링하기
16.4 요약


17장. 애플리케이션 개발을 위한 모범 사례

17.1 모든 것을 하나로 모아 보기
17.2 파드 라이프사이클 이해
17.2.1 애플리케이션이 종료되고 파드 재 배치 예상하기
17.2.2 종료된 파드 또는 부분적으로 종료된 파드를 다시 스케줄링하기
17.2.3 원하는 순서로 파드 시작
17.2.4 라이프사이클 훅 추가
17.2.5 파드 셧다운 이해하기
17.3 모든 클라이언트 요청의 적절한 처리 보장
17.3.1 파드가 시작될 때 클라이언트 연결 끊기 방지
17.3.2 파드 셧다운 동안 연결 끊어짐 방지
17.4 쿠버네티스에서 애플리케이션을 쉽게 실행하고 관리할 수 있게 만들기
17.4.1 관리 가능한 컨테이너 이미지 만들기
17.4.2 이미지에 적절한 태그를 지정하고 imagePullPolicy를 현명하게 사용
17.4.3 일차원 레이블 대신 다차원 레이블 사용
17.4.4 어노테이션으로 각 리소스 설명
17.4.5 프로세스가 종료된 원인에 대한 정보 제공
17.4.6 애플리케이션 로깅 처리
17.5 개발 및 테스트 모범사례
17.5.1 개발 중 쿠버네티스 외부에서 애플리케이션 실행
17.5.2 개발 중 Minikube 사용
17.5.3 버전 관리 및 자동 배포 리소스 매니페스트
17.5.4 YAML/JSON 매니페스트 대안으로 Ksonnet 소개
17.5.5 지속적 통합과 지속적 배포
17.6 요약


18장. 쿠버네티스의 확장

18.1 사용자 정의 API 오브젝트 정의
18.1.1 CustomResourceDefinition 소개
18.1.2 사용자 정의 컨트롤러로 사용자 정의 리소스 자동화
18.1.3 사용자 정의 오브젝트 유효성 검증
18.1.4 사용자 정의 오브젝트를 위한 사용자 정의 API 서버 제공
18.2 쿠버네티스 서비스 카탈로그를 통한 쿠버네티스 확장
18.2.1 서비스 카탈로그 소개
18.2.2 서비스 카탈로그 API 서버 및 컨트롤러 매니저 소개
18.2.3 Service Broker와 OpenServiceBroker API 소개
18.2.4 프로비저닝과 서비스 사용
18.2.5 바인딩 해제와 프로비저닝 해제
18.2.6 서비스 카탈로그의 이점 이해
18.3 쿠버네티스 기반 플랫폼
18.3.1 레드햇 오픈시프트 컨테이너 플랫폼
18.3.2 Deis Workflow and Helm
18.4 요약

부록 A. 다중 클러스터 환경에서 kubectl 사용하기

부록 B. kubeadm을 사용한 다중 노드 클러스터 설정하기

부록 C. 다른 컨테이너 런타임 사용하기

부록 D. 클러스터 페더레이션

책에서 다루는 쿠버네티스 리소스

접기
